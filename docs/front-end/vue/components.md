# 组件玩法

[Vue参考](https://cn.vuejs.org/)

----


- 组件注册
  - 全局注册
  - app.component('compName',component)
  - 局部注册(仅在当前组件内可用)
  - import之后直接用
  - 不用语法糖 components:{compName:component}
- Props
  - `const props = defineProps(['foo'])`访问时为props.foo
  - defineProps({title: String,likes: Number}) 使用对象形式限定类型
  - 不使用语法糖
  - props: ['foo']
  - setup(props){log(props.foo)}
  - 为了和 HTML attribute 对齐thePropsMess->the-props-mess
  - v-bind 用法
  - 可以用v-bind动态传值
  - 不加冒号的都是字符串 加冒号表示js表达式:porp="任何类型" "42/false/[1,2]/{}"
  - v-bind="classA" 等于将对象中的属性和值都传进去
  - 单向数据流
  - 不要在子组件中给其赋/改值
  - 在大多数的用例场景中，子组件都应该抛出一个事件来通知父组件做出改变
  - prop校验略
  - defineProps({disabled: Boolean}) `<MyComponent disabled />` 写了表true 不写表false
- 组件事件
  - 抛出与监听事件
  - $(emit()) 抛出事件 @ 监听事件
  - 事件参数
  - $emit('func', 7) &  @func="(n)=>log(n)"
  - 声明抛出的事件
  - const emit = defineEmits(['func1', 'func2'])
  - emits: ['inFocus', 'submit'] setup(props,ctx){ctx.emit('submit')}
  - 也支持以对象作为值实现验证
  - func:(n,m)=>n>m 返回t/f
  - v-model 用法
  - 实现与组件输入的双向绑定
  - defineProps(['modelValue']);defineEmits(['update:modelValue'])
  - `<input :vlue="modelValue" @input="$emit('update:modelValue',$event.target.value)">`
  - `<CustomInput v-model="orientText" />`
  - 多个绑定略
  - 自定义的修饰符略 @input="func"在函数里面写逻辑
- 透传 attribute
  - 当一个组件以单根节点时，透传的 attribute 会自动添加到根元素的 attribute 中
  - 继承如class style id v-on
  - 禁用略
  - 多个根元素时可以使用v-bind="$attrs"来指定
  - 使用 useAttrs()来访问一个组件的所有透传
- 插槽
  - `<slot>` 插口
  - 在里面写的作为默认内容
  - name="" 默认命名为"default"
  - `<template v-slot:theName>` 插头 v-slot:->#
  - `#[dynamicName]`动态插槽
  - 访问子组件中的值
  - `<slot m="string" name="abc">`
  - 可以使用v-bind="对象"传全部值
  - `<MyComonent v-slot="newName">{{newName.m}}</>`
  - `<template #abc="newObj">{{newObj.a/b/c}} or #abc={a,b,c}`然后直接用
  - 无渲染组件
  - 子组件只包括逻辑 不做渲染 将数据用`<slot>`传值
  - `<template><slot :a="a" :b="b" /></>`
  - 要渲染成什么样子全部交给插头
- 依赖注入(用于给过深的组件传值)
  - `provide('key', value)`
  - `const key = inject('key'[,'默认值'])`
- 异步组件(从服务器加载相关组件)
  - defineAsyncComponent
